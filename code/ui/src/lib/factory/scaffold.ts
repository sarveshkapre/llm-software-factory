import { constants as fsConstants } from "node:fs";
import fs from "node:fs/promises";
import path from "node:path";

import type { FactoryRun, PathValidationResult, ProjectScaffoldResult } from "@/lib/factory/types";

type RunForScaffold = Omit<FactoryRun, "scaffold" | "screenshots">;

function slugify(value: string): string {
  return value
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/^-+|-+$/g, "")
    .slice(0, 64);
}

async function pathExists(value: string): Promise<boolean> {
  try {
    await fs.stat(value);
    return true;
  } catch (error) {
    if (error instanceof Error && "code" in error && error.code === "ENOENT") {
      return false;
    }
    throw error;
  }
}

async function ensureUniqueProjectPath(rootPath: string, baseName: string): Promise<string> {
  let attempt = 1;
  let candidate = path.join(rootPath, baseName);

  while (await pathExists(candidate)) {
    attempt += 1;
    candidate = path.join(rootPath, `${baseName}-${attempt}`);
  }

  return candidate;
}

function buildRootReadme(run: RunForScaffold, relativeProjectPath: string): string {
  const moduleNames = run.blueprint.modules.map((module) => `- ${module.name}`).join("\n");

  return [
    `# ${run.intent.productName}`,
    "",
    "Built by Codex, LLM AI Software Factory.",
    "",
    "## Prompt",
    "",
    run.prompt,
    "",
    "## Source Reference",
    "",
    `- Baseline URL: ${run.target.url}`,
    `- Target selection: ${run.target.strategy}`,
    "",
    "## Project Skeleton",
    "",
    `- Workspace root: ${relativeProjectPath}`,
    "- apps/web",
    "- apps/api",
    "- packages/shared",
    "- docs",
    "- artifacts/screenshots",
    "",
    "## Delivery Modules",
    "",
    moduleNames,
    "",
  ].join("\n");
}

function buildBlueprintDoc(run: RunForScaffold): string {
  const modules = run.blueprint.modules
    .map((module) => {
      const deliverables = module.deliverables.map((entry) => `- ${entry}`).join("\n");
      return [`## ${module.name}`, "", module.goal, "", deliverables, ""].join("\n");
    })
    .join("\n");

  const phases = run.blueprint.phases.map((phase) => `- ${phase}`).join("\n");

  return [
    "# Build Blueprint",
    "",
    run.blueprint.positioning,
    "",
    modules,
    "## Implementation Phases",
    "",
    phases,
    "",
  ].join("\n");
}

function buildCrawlDoc(run: RunForScaffold): string {
  const endpoints = run.crawl.endpoints.map((endpoint) => `- ${endpoint}`).join("\n");
  const screenshots = run.crawl.screenshotPlan
    .map((shot) => `- ${shot.label}: ${shot.artifactPath}`)
    .join("\n");

  return [
    "# Crawl Snapshot",
    "",
    `- Title: ${run.crawl.pageTitle}`,
    `- Summary: ${run.crawl.summary}`,
    "",
    "## Endpoints",
    "",
    endpoints,
    "",
    "## Screenshot Plan",
    "",
    screenshots,
    "",
  ].join("\n");
}

function buildWorkspacePackageJson(projectName: string): string {
  return JSON.stringify(
    {
      name: projectName,
      private: true,
      version: "0.1.0",
      description: "Generated by Codex LLM AI Software Factory",
      workspaces: ["apps/*", "packages/*"],
      scripts: {
        dev: "echo \"Run web/api app setup\"",
        build: "echo \"Wire build commands for apps\"",
        lint: "echo \"Wire lint commands for apps\"",
      },
    },
    null,
    2
  );
}

function buildGitignore(): string {
  return [
    "node_modules/",
    ".next/",
    "dist/",
    "build/",
    ".env",
    ".env.local",
    "coverage/",
    "artifacts/screenshots/",
    "*.log",
    "",
  ].join("\n");
}

function buildAppReadme(appName: string): string {
  return [
    `# ${appName}`,
    "",
    "Built by Codex, LLM AI Software Factory.",
    "",
    "Scaffold placeholder. Implement production modules based on docs/blueprint.md.",
    "",
  ].join("\n");
}

export async function validateOutputRootPath(rawPath: string): Promise<PathValidationResult> {
  const trimmed = rawPath.trim();

  if (trimmed.length === 0) {
    return {
      valid: false,
      resolvedPath: "",
      message: "Output root path is required.",
    };
  }

  const resolvedPath = path.resolve(trimmed);

  if (!path.isAbsolute(resolvedPath)) {
    return {
      valid: false,
      resolvedPath,
      message: "Please provide an absolute local path.",
    };
  }

  try {
    const stats = await fs.stat(resolvedPath);

    if (!stats.isDirectory()) {
      return {
        valid: false,
        resolvedPath,
        message: "Path exists but is not a directory.",
      };
    }

    await fs.access(resolvedPath, fsConstants.W_OK);

    return {
      valid: true,
      resolvedPath,
      message: "Path is valid and writable.",
    };
  } catch (error) {
    if (error instanceof Error && "code" in error && error.code === "ENOENT") {
      return {
        valid: false,
        resolvedPath,
        message: "Path does not exist. Create it first, then validate again.",
      };
    }

    return {
      valid: false,
      resolvedPath,
      message: "Unable to access path. Check permissions.",
    };
  }
}

interface ScaffoldOptions {
  outputRootPath: string;
  fullOwnership: boolean;
}

export async function scaffoldProject(
  run: RunForScaffold,
  options: ScaffoldOptions
): Promise<ProjectScaffoldResult> {
  const baseFolder = slugify(run.intent.productName) || "generated-product";
  const projectPath = await ensureUniqueProjectPath(options.outputRootPath, baseFolder);

  await fs.mkdir(projectPath, { recursive: true });

  const relativeProjectPath = path.relative(options.outputRootPath, projectPath) || path.basename(projectPath);

  const files: Array<{ relativePath: string; content: string }> = [
    {
      relativePath: "README.md",
      content: buildRootReadme(run, relativeProjectPath),
    },
    {
      relativePath: "docs/blueprint.md",
      content: buildBlueprintDoc(run),
    },
    {
      relativePath: "docs/crawl-snapshot.md",
      content: buildCrawlDoc(run),
    },
    {
      relativePath: ".gitignore",
      content: buildGitignore(),
    },
    {
      relativePath: "package.json",
      content: buildWorkspacePackageJson(baseFolder),
    },
    {
      relativePath: "apps/web/README.md",
      content: buildAppReadme("Web App"),
    },
    {
      relativePath: "apps/api/README.md",
      content: buildAppReadme("API App"),
    },
    {
      relativePath: "packages/shared/README.md",
      content: buildAppReadme("Shared Package"),
    },
    {
      relativePath: "factory/run.json",
      content: JSON.stringify(run, null, 2),
    },
  ];

  if (options.fullOwnership) {
    files.push(
      {
        relativePath: "apps/web/src/README.md",
        content:
          "# Web Source\n\nBuilt by Codex, LLM AI Software Factory.\n\nImplement pages/components from docs/blueprint.md.\n",
      },
      {
        relativePath: "apps/api/src/README.md",
        content:
          "# API Source\n\nBuilt by Codex, LLM AI Software Factory.\n\nImplement route handlers and domain services from docs/blueprint.md.\n",
      },
      {
        relativePath: ".env.example",
        content: "# Built by Codex, LLM AI Software Factory\nAPP_NAME=generated-product\n",
      }
    );
  }

  const createdFiles: string[] = [];

  for (const file of files) {
    const absolutePath = path.join(projectPath, file.relativePath);
    await fs.mkdir(path.dirname(absolutePath), { recursive: true });
    await fs.writeFile(absolutePath, file.content, "utf8");
    createdFiles.push(file.relativePath);
  }

  await fs.mkdir(path.join(projectPath, "artifacts/screenshots"), { recursive: true });

  return {
    outputRootPath: options.outputRootPath,
    projectName: baseFolder,
    projectPath,
    fullOwnership: options.fullOwnership,
    createdFiles,
  };
}
